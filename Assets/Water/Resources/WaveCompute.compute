// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Tick
#include "WaterHelperLib.cginc"
#include "HLSLSupport.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> WaveTexture;
RWTexture2D<float4> WaveDisplacement;
RWTexture2D<float4> WaveNormal;
RWTexture2D<float4> WaveFoamJocobian;
RWTexture2D<float4> WaveFoamJxy;

CBUFFER_START(WaveBuffer)
float time;
float unitLen;
float4 direction;
float4 wind;
float steepness;
float amplitude;
float waveLength;
float speed;
CBUFFER_END




[numthreads(8,8,1)]
void Tick(uint3 id : SV_DispatchThreadID)
{
	float width, height;
	WaveTexture.GetDimensions(width, height);
	//float2 uv = id.xy / float2(width, height);
	float2 uv = id.xy / float2(2, 2);


    float2 k = ( (uv - .4999) * 2.0 * 3.1415926) / unitLen;
    float len_k = length(k);
    float inv_k = len_k == 0 ? 0 : 1 / len_k;
    float2 windDir = wind.xy;

	float2 gp0 = gaussian_pair(uv + float2(0.6, 0.1), time);
	float2 h0k = gp0 * (sqrt(PhilipSpectrum(amplitude, k, windDir, 9.8)) /  sqrt(2));

    float2 gp1 = gaussian_pair(uv + float2(0.2, 0.3), time);
	float2 h0mk = gp1 * (sqrt(PhilipSpectrum(amplitude, -k, windDir, 9.8)) / sqrt(2));
	float wkt = sqrt(9.8 * length(k)) * (time + nrand(time) * 0.01f) * 1; // Add small random factor make it more unpredictable

	// exp(jwt) = cos(wt) + j * sin(wt)
	float e_cos = cos(wkt);
	float e_sin = sin(wkt);


	float2 exp0 = float2( e_cos, e_sin);
	float2 exp1 = float2( e_cos, -e_sin);

	float2 h0k_exp = complex_mul(exp0, h0k);
	float2 h0k_exp_inv = complex_mul(exp1, h0mk);

    float2 h = h0k_exp + h0k_exp_inv;
    
    //xz : -i * (K / |k|) * h(K, t)
    float2 d_x = complex_mul(float2(0, -1), complex_mul(float2(k.x / length(k), 0), h));
    float2 d_y = complex_mul(float2(0, -1), complex_mul(float2(k.y / length(k), 0), h));

    float2 n_x = complex_mul(float2(0, 1), complex_mul(float2(k.x, 0), h));
    float2 n_y = complex_mul(float2(0, 1), complex_mul(float2(k.y, 0), h));
    
    float jx = -(k * k).x * h.x * inv_k;
    float jy = -(k * k).y * h.x * inv_k;
    float jxy = -(k.x * k.y) * h.x;
    //float j = jx + jy + jx*jy -jxy * jxy;
    //j *= 1000;

    float3 result;
	result.xyz = float3(h.x, h.y, 0.0);
	WaveTexture[id.xy] = float4(result.x, result.y, 1.0, 1.0);
    WaveDisplacement[id.xy] = float4(d_x.x, d_x.y, d_y.x, d_y.y);
    WaveNormal[id.xy] = float4(n_x.x, n_x.y, n_y.x, n_y.y);
    WaveFoamJocobian[id.xy] = float4(jx, 0, jy, 0);
    WaveFoamJxy[id.xy] = float4(jxy, 0, 0, 0);
}
